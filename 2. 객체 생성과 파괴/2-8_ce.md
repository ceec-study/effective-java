# finalizer와 cleaner 사용을 피하자

## 결론

> finalizer와 cleaner는 예측 불가능하고 위험하기 때문에 되도록이면 사용하지 말자.
> <br/> 사용한다면 안전망 역할이나 중요하지 않은 네이티브 자원 회수용으로만 사용하자.

<br/>

## finalizer와 cleaner

- finalizer와 cleaner는 객체 소멸자이다.
- 자바에는 가비지 컬렉터가 있기 때문에 보통 finalizer와 cleaner는 불필요하다.
- finalizer와 cleaner는 예측할 수 없고, 위험하며 느리기 때문에 사용하지 말자.

  - 호출 시점이 보장되지 않기 때문에 예측할 수 없다.
  - 따라서 제때 실행되어야 하는 작업에서 사용할 수 없다.

- finalizer의 실행 시점은 가비지 컬렉터 알고리즘에 달렸다.

- finalizer보다 cleaner가 비교적 덜 위험하다.

  - cleaner는 자신을 수행할 스레드를 제어할 수 있기 때문에

- finalizer는 예외를 무시하여 그 순간 종료되지만, cleaner는 예외 처리가 가능하다. finalizer는 예외로 인해서 작업을 완료하지 못할 수 있으며 이는 커다란 문제를 불러올 수 있다.

- finalizer와 cleaner는 심각한 성능 문제를 동반한다.

  - 가비지 컬렉터의 효율을 떨어뜨리기 때문에

- finalizer를 사용한 클래스는 finalizer 공격에 노출되어 심각한 보안 문제를 일으킬 수 있다.

<br/>

## 사용

finalizer와 cleaner도 용도가 있다.

1. 안전망 역할

   - finalizer와 cleaner는 즉시 호출되지는 않지만, 나중에라도 호출되어 회수하지 못한 자원을 회수하는 역할을 한다.

2. 네이티브 피어
   - 네이티브 피어: 일반 자바 객체가 네이티브 메서드를 통해 기능을 위힘한 네이티브 객체 (즉, 외부 자원을 뜻함)
   - 네이티브 피어는 자바 객체가 아니기 때문에 가비지 컬렉터가 회수할 수 없다. 이때 가비지 컬렉터 대신에 객체를 회수해준다.

<br/>

## 대안

- 클래스에 `AutoCloseable`을 구현하고, 인스턴스를 다 사용한 후에 `close` 메서드를 호출하면 된다.
- 예외가 발생해도 제대로 종료되도록 [try-with-resources]()를 사용한다.
