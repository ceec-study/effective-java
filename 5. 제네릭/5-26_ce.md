# 제네릭

- 제네릭을 사용하기 전에는 컬렉션에서 객체를 꺼낼 때마다 형변환을 해야했다.
  - 이때 실수하게 되면 런타임에 형변환 오류가 발생
- 제네릭을 사용하면 컬렉션이 담을 수 있는 타입을 컴파일러에게 알려주기 때문에 컴파일링 과정에서 오류를 잡을 수 있다.
  - 오류를 컴파일 과정에서 차단하여 더 안전한 프로그램을 만들 수 있음
  - 하지만 코드가 복잡해진다는 단점은 있다.

## 로 타입은 사용하지 말자

- 로 타입: 제네릭 타입에서 타입 매개변수를 전혀 사용하지 않을 때를 말함
  - e.g. List, Set

### 로 타입의 문제점

```java
private final Collection stamps = new ArrayList();
stamps.add(new Coin()); // ClassCastException 발생
```

- stamps에 Coin을 넣어도 아무 오류 없이 `컴파일`이 되고 나중에 `런타임`이 되서야 오류를 확인할 수 있다.
- 오류는 가능한 컴파일할 때 발견하는 것이 좋다.
- 로 타입을 쓰면 제네릭의 장점인 안전성과 표현력을 모두 잃게 되는 것이다.

```java
// 수정한 코드
// 타입의 안전성 확보
private final Collection<Stamp> stamps = new ArrayList<>();
stamps.add(new Coin()); // 컴파일 에러 발생
```

### 로 타입을 쓰는 경우

- 이러한 위험성에도 로 타입이 사용되는 이유는 호환성 때문이다.
  - 제네릭이 생기기 전에, 제네릭 없이 짠 코드가 많이 존재하기 때문이다.
- class 리터럴, instanceof 연산자를 사용할 때는 로 타입을 사용한다.

### List vs List<Object> vs List<?>

- List: 제네릭을 아예 뺌
  - 안전성 X
  - 런타임에서 오류 발생
- List<Object> : 어떤 타입의 객체도 저장할 수 있는 매개변수화 타입
  - 안전성 O
  - 컴파일에서 오류 발생
- List<?> : 모종의 타입의 객체만 저장할 수 있는 와일드카드 타입
  - 안전성 O
  - 컴파일에서 오류 발생

## 비한정적 와일드카드 타입(Unbounded wildcard type)

- 만약 제네릭 타입을 사용하고 싶지만, 실제 타입 매개변수가 무엇인지 신경 쓰고 싶지 않다면 <?> (비한정적 와일드카드 타입)을 사용하자.
- 장점: 안전하며 유연하다.
